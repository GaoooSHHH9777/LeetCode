/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

// 递归
// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.
// Memory Usage: 38.6 MB, less than 5.04% of Java online submissions for Reverse Linked List.

// 循环
// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.
// Memory Usage: 38.2 MB, less than 5.04% of Java online submissions for Reverse Linked List.

class Solution {
    // 递归
//     public ListNode reverseList(ListNode head) {
//         return recursive(head, null);
//     }

//     private ListNode recursive(ListNode current, ListNode newNext){
//         if(current == null){
//             return newNext;                          // 想一下就能通，不描述了，费字
//         }

//         ListNode oldNext = current.next;
//         current.next = newNext;

//         return recursive(oldNext, current);          // 注意它是有返回值的，直接return调用这个方法即可
//     }
    
    // 循环
    public ListNode reverseList(ListNode head) {
        // 起名为bubblePointer，因为它会随着循环，tail -> head，就像冒泡排序的过程一样
        // 需要为null，不能是0，不然输出有误。因为它在第一个循环会被赋给tail.next，如果它不为null，那它就会被输出为0了（为null则不输出了，只不过从逻辑上来说它确实是最底的tail）
        ListNode bubblePointer = null;      

        while(head != null){
            // 每次考虑下一个位置的node就行，一开始总在思考后面两个位置的node，所以写不对
            ListNode realNext = head.next;
            head.next = bubblePointer;
            bubblePointer = head;           // 就是这一步使得它逐步地：tail -> head
            head = realNext;
        }

        return bubblePointer;               // 最终，它已经是head了，输出即可
    }
}
