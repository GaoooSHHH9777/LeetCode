// Runtime: 2 ms, faster than 99.83% of Java online submissions for Median of Two Sorted Arrays.
// Memory Usage: 41.8 MB, less than 100.00% of Java online submissions for Median of Two Sorted Arrays.
    
class Solution {

    int[] A;
    int[] B;

    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        this.A = nums1;
        this.B = nums2;
        
        int sumLength = A.length + B.length;
        
        if(sumLength % 2 == 0){
            double left = getKth(0, 0, sumLength/2);
            double right = getKth(0, 0, sumLength/2 + 1);
            return (left + right)/2;
        }else{
            return getKth(0, 0, sumLength/2 + 1);
        }
    }

    public double getKth(int aStart, int bStart, int k) {
        if (aStart > A.length - 1) {
            // If A is exhausted, return kth number in B
            return B[bStart + k - 1];       
        }
        if (bStart > B.length - 1) {
            // If B is exhausted, return kth number in A
            return A[aStart + k - 1];   
        }
        
        if(k == 1){
            return Math.min(A[aStart], B[bStart]);
        }
        
        // [2,4,6,8,10,12]，从arr[3]开始数两个数字，newIndex = 3+2-1 => arr[4]。所以要-1
        int midIndexA = aStart + k/2 - 1;
        int midIndexB = bStart + k/2 - 1;
        
        int midValA = midIndexA < A.length ? A[midIndexA] : Integer.MAX_VALUE;
        int midValB = midIndexB < B.length ? B[midIndexB] : Integer.MAX_VALUE;
        
        // Throw away half of the array from A or B. And cut k in half
        if (midValA < midValB) {             // 这里是<或者<=都可以
            // Check: aRight + bLeft 
            return getKth(midIndexA+1, bStart,      k - k/2);     // k - k/2并不等价于k/2，因为是int。比如1/2=0，但是1 - 1/2 = 1，是不一样的
        }else {
            // Check: bRight + aLeft
            return getKth(aStart,      midIndexB+1, k - k/2);     
        }
    }
}
