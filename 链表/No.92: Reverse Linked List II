/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

// Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List II.
// Memory Usage: 37.5 MB, less than 11.36% of Java online submissions for Reverse Linked List II.

class Solution {
    
    // 没想出来，有点抽象，不靠纸笔空想有点乱。讲道理也就是中间部分进行easy-链表反转，咋就恁笨呢？？？？
    
    public ListNode reverseBetween(ListNode head, int m, int n) {
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        
        // 这里这个before变量必须要，不能直接用head然后m-2循环。举个过不了的反例case：node数量=1，m=1，n=1，会导致25行空指针异常！！！
        ListNode before = dummyHead;
        
        // 找到“需要反转链表的area的前一个node位置”，所以是m-1
        for(int i=0; i<m-1; i++){       // 也许下次可以尝试while(x>0或x>1){ x-- }这样的逻辑
            before = before.next;
        }

        // 标记出“反转链表area”的首个node。它要逐步冒泡到右边
        ListNode bubblePointer = before.next;
        // 标记处“反转链表area”的执行node（也算是个指针）
        ListNode second = bubblePointer.next;

        // 。。。。一不小心就会写出链表环了
        for(int i=0; i<n-m; i++){
            // 假设1->2->3->4->5，交换2～4。即area=2～4，before=1，first=2，second=3
            bubblePointer.next = second.next;           // 切断2->3，改为2->4。node3已经保存为second了，不用担心
            second.next = before.next;                  // 切断3->4，改为3->2。这里不能写bubblePointer！！！只有第一次的时候before.next是bubblePointer。然而before是不动的，bubblePointer是动的！
            before.next = second;                       // 切断1->2，改为1->3。
            second = bubblePointer.next;                // second前进（右移）
        }

        // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4
        // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)
        
        return dummyHead.next;
    }
    
//     public ListNode reverseBetween(ListNode head, int m, int n){
//         if (head == null || head.next == null || m <= 0 || n <= 0) {
//             return head;
//         }
//         ListNode dummyNode = new ListNode(0);
//         dummyNode.next = head;
//         ListNode pre = dummyNode;
//         ListNode start = head;

//         for (int i = 0; i < m - 1; i++) {
//             pre = pre.next;
//             start = start.next;
//         }

//         // flow of execution in each iteration (for the 2nd input): 1->2->3->4->5->6->7  |  1->2->4->3->5->6->7 | 1->2->5->4->3->6->7 | 1->2->6->5->4->3->7 | 1->2->7->6->5->4->3
//         for (int i = 0; i < n - m; i++) {
//             ListNode current = start.next;
//             start.next = current.next;
//             current.next = pre.next;
//             pre.next = current;
//         }
//         return dummyNode.next;
//     }
}
